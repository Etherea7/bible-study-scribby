import type { VercelRequest, VercelResponse } from '@vercel/node';
import { generateStudyWithFallback } from './_shared';

// ESV API configuration
const ESV_API_URL = 'https://api.esv.org/v3/passage/text/';

/**
 * Fetch passage from ESV API
 */
async function fetchPassage(reference: string, includeHeadings: boolean = true): Promise<string> {
    const apiKey = process.env.ESV_API_KEY;
    if (!apiKey) {
        return '[ESV API key not configured. Please add ESV_API_KEY to environment variables.]';
    }

    const params = new URLSearchParams({
        q: reference,
        'include-headings': includeHeadings ? 'true' : 'false',
        'include-footnotes': 'false',
        'include-verse-numbers': 'true',
        'include-short-copyright': 'true',
        'include-passage-references': includeHeadings ? 'true' : 'false',
    });

    try {
        const response = await fetch(`${ESV_API_URL}?${params}`, {
            headers: {
                Authorization: `Token ${apiKey}`,
            },
        });

        if (!response.ok) {
            return `[Error fetching passage: HTTP ${response.status}]`;
        }

        const data = await response.json();
        const passages = data.passages || [];
        return passages[0]?.trim() || `[No passage found for: ${reference}]`;
    } catch (error) {
        return `[Error connecting to ESV API: ${error instanceof Error ? error.message : 'Unknown error'}]`;
    }
}

/**
 * Build reference string from components with cross-chapter support
 */
function buildReference(
    book: string,
    startChapter: number,
    startVerse?: number,
    endChapter?: number,
    endVerse?: number
): string {
    // Default end chapter to start chapter if not provided
    const effectiveEndChapter = endChapter ?? startChapter;

    // No verses specified
    if (!startVerse) {
        if (startChapter === effectiveEndChapter) {
            return `${book} ${startChapter}`;
        }
        return `${book} ${startChapter}-${effectiveEndChapter}`;
    }

    // Same chapter case
    if (startChapter === effectiveEndChapter) {
        if (!endVerse || endVerse === startVerse) {
            return `${book} ${startChapter}:${startVerse}`;
        }
        return `${book} ${startChapter}:${startVerse}-${endVerse}`;
    }

    // Cross-chapter case
    if (!endVerse) {
        return `${book} ${startChapter}:${startVerse}-${effectiveEndChapter}`;
    }
    return `${book} ${startChapter}:${startVerse}-${effectiveEndChapter}:${endVerse}`;
}

/**
 * POST /api/generate
 *
 * Generate a Bible study for the given passage.
 * This is the main serverless function that replaces the FastAPI backend.
 */
export default async function handler(req: VercelRequest, res: VercelResponse) {
    // Only allow POST
    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method not allowed' });
    }

    try {
        const { book, chapter, start_verse, end_chapter, end_verse } = req.body;

        // Validate required fields
        if (!book || typeof chapter !== 'number') {
            return res.status(400).json({ error: 'Missing required fields: book, chapter' });
        }

        // Build reference string (with cross-chapter support)
        const reference = buildReference(book, chapter, start_verse, end_chapter, end_verse);

        console.log(`[API] Generating study for: ${reference}`);

        // Fetch passage text from ESV API (include headings for study generation)
        const passageText = await fetchPassage(reference, true);

        // Generate study using LLM with fallback
        const { study, provider } = await generateStudyWithFallback(reference, passageText);

        console.log(`[API] Study generated by: ${provider}`);

        return res.status(200).json({
            reference,
            passage_text: passageText,
            study,
            provider,
        });
    } catch (error) {
        console.error('[API] Error generating study:', error);
        return res.status(500).json({
            error: error instanceof Error ? error.message : 'Internal server error',
        });
    }
}
