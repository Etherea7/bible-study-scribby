from fastapi import FastAPI, Request
from fastapi.responses import HTMLResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from pydantic import BaseModel
from typing import Optional
import logging

from services.reading_plan import (
    get_reference,
    BIBLE_BOOKS,
)
from services.esv_api import fetch_passage
from services.llm_router import generate_study_with_fallback, check_provider_status
from services.bible_data import validate_verse_range, get_chapter_count

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


app = FastAPI(title="Scribby")

# Mount static files (will be replaced by React in Phase 4)
app.mount("/static", StaticFiles(directory="static"), name="static")

# Setup templates (will be replaced by React in Phase 4)
templates = Jinja2Templates(directory="templates")


# Request model for /generate endpoint
class GenerateStudyRequest(BaseModel):
    book: str
    chapter: int
    start_verse: Optional[int] = None
    end_chapter: Optional[int] = None  # For cross-chapter ranges
    end_verse: Optional[int] = None


@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    """Display Bible study with pre-loaded default (John 1:1-18)."""
    # Default to John 1:1-18
    book = "John"
    chapter = 1
    start_verse = 1
    end_verse = 18

    reference = get_reference(book, chapter, start_verse, end_verse)

    # Fetch passage text
    passage_text = await fetch_passage(reference)

    # Generate study using LLM router
    study, provider = await generate_study_with_fallback(reference, passage_text)

    logger.info(f"Home page study generated by: {provider}")

    return templates.TemplateResponse(
        "index.html",
        {
            "request": request,
            "bible_books": BIBLE_BOOKS,
            "selected_book": book,
            "selected_chapter": chapter,
            "selected_start_verse": start_verse,
            "selected_end_verse": end_verse,
            "reference": reference,
            "passage_text": passage_text,
            "study": study,
        },
    )


@app.post("/api/generate")
async def generate_study_endpoint(req: GenerateStudyRequest):
    """Generate Bible study for specified passage (API endpoint for React frontend)."""
    # Validate chapter exists for the book
    max_chapters = get_chapter_count(req.book)
    if max_chapters == 0:
        return JSONResponse(
            status_code=400,
            content={"error": "Invalid book name"}
        )

    if req.chapter < 1 or req.chapter > max_chapters:
        return JSONResponse(
            status_code=400,
            content={"error": f"Chapter must be between 1 and {max_chapters} for {req.book}"}
        )

    # Determine end chapter (defaults to start chapter)
    end_chapter = req.end_chapter if req.end_chapter is not None else req.chapter
    
    # Validate end chapter
    if end_chapter < req.chapter or end_chapter > max_chapters:
        return JSONResponse(
            status_code=400,
            content={"error": f"End chapter must be between {req.chapter} and {max_chapters}"}
        )

    # Validate verse range if provided (for single chapter, use original validation)
    if req.start_verse is not None and req.end_verse is not None:
        if req.chapter == end_chapter:
            # Same chapter: use standard validation
            if not validate_verse_range(req.book, req.chapter, req.start_verse, req.end_verse):
                return JSONResponse(
                    status_code=400,
                    content={"error": "Invalid verse range"}
                )
        # For cross-chapter, the ESV API will validate the verse ranges

    # Build reference string (with cross-chapter support)
    reference = get_reference(req.book, req.chapter, req.start_verse, req.end_verse, end_chapter)

    # Fetch passage text
    passage_text = await fetch_passage(reference)

    # Generate study using LLM router with fallback
    study, provider = await generate_study_with_fallback(reference, passage_text)

    logger.info(f"API study generated by: {provider}")

    return {
        "reference": reference,
        "passage_text": passage_text,
        "study": study,
        "provider": provider
    }


# Keep old endpoint for backward compatibility with current frontend
@app.post("/generate")
async def generate_study_legacy(req: GenerateStudyRequest):
    """Legacy endpoint for backward compatibility with Jinja2 frontend."""
    return await generate_study_endpoint(req)


@app.get("/api/providers")
async def get_providers():
    """Get status of all LLM providers."""
    status = await check_provider_status()
    return {"providers": status}


class FetchPassageRequest(BaseModel):
    reference: str
    include_headings: bool = True  # Set to False for preview (cleaner display)


@app.post("/api/passage")
async def fetch_passage_endpoint(req: FetchPassageRequest):
    """Fetch Bible passage text from ESV API (for blank study creation or preview)."""
    try:
        passage_text = await fetch_passage(req.reference, req.include_headings)
        return {"passage_text": passage_text}
    except Exception as e:
        logger.error(f"Error fetching passage: {e}")
        return JSONResponse(
            status_code=400,
            content={"error": str(e)}
        )


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host="0.0.0.0", port=8000)
